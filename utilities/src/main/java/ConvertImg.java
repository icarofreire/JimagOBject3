/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package jimagobject.utilities;

import java.nio.ByteBuffer;
import java.awt.image.DataBuffer;
import java.awt.image.WritableRaster;
import java.awt.image.ColorModel;
import java.awt.image.DataBufferUShort;
import java.awt.image.Raster;
import java.awt.image.ComponentColorModel;
import java.awt.Transparency;
import java.awt.color.ColorSpace;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import javax.imageio.ImageIO;
import java.io.ByteArrayOutputStream;
import java.util.Iterator;
import javax.imageio.ImageReader;
import javax.imageio.stream.ImageInputStream;
import java.io.OutputStream;
import java.io.BufferedOutputStream;
import javax.imageio.ImageReadParam;
import java.awt.Image;
import java.io.File;
import java.awt.image.WritableRaster;
// import java.nio.IntBuffer;
import java.nio.ByteOrder;
import java.awt.image.DataBufferByte;
import java.awt.image.ColorModel;
import java.awt.image.ComponentSampleModel;
import java.awt.image.SampleModel;
import java.awt.Graphics2D;
// import java.util.Base64;

// import jimagobject.utilities.ReadImages;

/*
 * classe para processo de convers√£o de dados de imagem;
 */
public final class ConvertImg {

    public BufferedImage apply(byte[] bytesImage) {
        BufferedImage image = null;
        // image = byteToBufferedImageIMG(bytesImage);
        image = byteToBufferedImage(bytesImage);

        // byte[] encode = Base64.getEncoder().encode(bytesImage);
        // String result = new String(encode);
        // System.out.println(result);

        // image = createNoCopy(500, 500, bytesImage);
        // int m = 50000;
        // image = createRGBImage(bytesImage, 500, 500);

        //  IntBuffer intBuf =
        // ByteBuffer.wrap(bytesImage)
        //     .order(ByteOrder.BIG_ENDIAN)
        //     .asIntBuffer();
        // int[] array = new int[intBuf.remaining()];
        // intBuf.get(array);

        // image = getImageFromArray(array, 50000, 50000);

        // System.out.println("IMG:" + image);
        return image;
    }

    // convert byte[] back to a BufferedImage
    public BufferedImage byteToBufferedImageIMG(byte[] bytes) {
        BufferedImage newBi = null;
        try{
            InputStream is = new ByteArrayInputStream(bytes);
            System.out.println("is::" + is);
            newBi = ImageIO.read(is);
        }catch(IOException e){
            e.printStackTrace();
        }
        return newBi;
    }

    // convert byte[] back to a BufferedImage
    public BufferedImage byteToBufferedImage(byte[] bytes) {
        BufferedImage newBi = null;
        newBi = createCopyUsingByteBuffer(5000, 5000, bytes);
        return newBi;
    }

    /**
     * https://stackoverflow.com/questions/42841566/pixel-data-of-a-16-bit-dicom-image-to-bufferedimage
     */
    private static BufferedImage createCopyUsingByteBuffer(int w, int h, byte[] rawBytes) {
        short[] rawShorts = new short[rawBytes.length / 2];

        ByteBuffer.wrap(rawBytes)
                .order(java.nio.ByteOrder.BIG_ENDIAN) // Depending on the data's endianness
                .asShortBuffer()
                .get(rawShorts);

        DataBuffer dataBuffer = new DataBufferUShort(rawShorts, rawShorts.length);
        int stride = 1;
        WritableRaster raster = Raster.createInterleavedRaster(dataBuffer, w, h, w * stride, stride, new int[] {0}, null);
        ColorModel colorModel = new ComponentColorModel(ColorSpace.getInstance(ColorSpace.CS_GRAY), false, false, Transparency.OPAQUE, DataBuffer.TYPE_USHORT);

        return new BufferedImage(colorModel, raster, colorModel.isAlphaPremultiplied(), null);
    }

    private BufferedImage createRGBImage(byte[] bytes, int width, int height) {
        DataBufferByte buffer = new DataBufferByte(bytes, bytes.length);
        ColorModel cm = new ComponentColorModel(ColorSpace.getInstance(ColorSpace.CS_sRGB), new int[]{8, 8, 8}, false, false, Transparency.OPAQUE, DataBuffer.TYPE_BYTE);
        return new BufferedImage(cm, Raster.createInterleavedRaster(buffer, width, height, width * 3, 3, new int[]{0, 1, 2}, null), false, null);
    }

    private BufferedImage createNoCopy(int w, int h, byte[] rawBytes) {
        DataBuffer dataBuffer = new DataBufferByte(rawBytes, rawBytes.length);

        int stride = 2;
        SampleModel sampleModel = new MyComponentSampleModel(w, h, stride);
        WritableRaster raster = Raster.createWritableRaster(sampleModel, dataBuffer, null);

        ColorModel colorModel = new ComponentColorModel(ColorSpace.getInstance(ColorSpace.CS_GRAY), false, false, Transparency.OPAQUE, DataBuffer.TYPE_USHORT);

        return new BufferedImage(colorModel, raster, colorModel.isAlphaPremultiplied(), null);
    }

    private class MyComponentSampleModel extends ComponentSampleModel {
        public MyComponentSampleModel(int w, int h, int stride) {
            super(DataBuffer.TYPE_USHORT, w, h, stride, w * stride, new int[] {0});
        }

        @Override
        public Object getDataElements(int x, int y, Object obj, DataBuffer data) {
            if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {
                throw new ArrayIndexOutOfBoundsException("Coordinate out of bounds!");
            }

            // Simplified, as we only support TYPE_USHORT
            int numDataElems = getNumDataElements();
            int pixelOffset = y * scanlineStride + x * pixelStride;

            short[] sdata;

            if (obj == null) {
                sdata = new short[numDataElems];
            }
            else {
                sdata = (short[]) obj;
            }

            for (int i = 0; i < numDataElems; i++) {
                sdata[i] = (short) (data.getElem(0, pixelOffset) << 8 | data.getElem(0, pixelOffset + 1));
                // If little endian, swap the element order, like this:
            //    sdata[i] = (short) (data.getElem(0, pixelOffset + 1) << 8 | data.getElem(0, pixelOffset));
            }

            return sdata;
        }
    }

    public BufferedImage Dicom2MemJPEG(File dcmFile, int scaleHeight){
        //File myDicomFile = new File("c:/dicomImage.dcm");
        BufferedImage myJpegImage = null;
        
        // returns an Iterator containing all currently registered ImageReaders 
        // that claim to be able to decode the named format 
        // (e.g., "DICOM", "jpeg", "tiff")
        Iterator iter = ImageIO.getImageReadersByFormatName("DICOM");  
        ImageReader reader = (ImageReader) iter.next();
        // DicomImageReadParam param = (DicomImageReadParam) reader.getDefaultReadParam();
        ImageReadParam param = reader.getDefaultReadParam();
        
        try {
            ImageInputStream iis = ImageIO.createImageInputStream(dcmFile);
            reader.setInput(iis, false); 
            myJpegImage = reader.read(0, param); 
            iis.close();

            if (myJpegImage == null) {
                System.out.println("\nError: couldn't read dicom image!");
                return null;
            }
            

            // Resize Image -> Thumbnails....
            if (scaleHeight > 0){
                if (scaleHeight < 24) 
                    scaleHeight = 24; // minimum
                myJpegImage = getScaledImageWithHeight(myJpegImage, scaleHeight);           
            }
                    
            //OutputStream output = new BufferedOutputStream(new FileOutputStream(jpgFile));
            ByteArrayOutputStream jpgArray = new ByteArrayOutputStream();
            OutputStream output = new BufferedOutputStream(jpgArray); 
            
            //JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(output);
            //encoder.encode(myJpegImage);
            output.close();             // Has no effect to ByteArrayOutputStream
            
            // return jpgArray;
            return myJpegImage;
        } 
        catch(IOException e) {
            System.out.println("\nError: couldn't read dicom image!"+ e.getMessage());
            return null;
        }
        catch(Exception e) {
            System.out.println("\nError: "+ e.getMessage());
            return null;
        }
    }

    /**A method that scales a Buffered image and takes the required height as a refference point**/
    public static BufferedImage getScaledImageWithHeight(BufferedImage image, int height) throws java.lang.Exception {
        int width = (int) (((float) image.getWidth() / (float) image.getHeight()) * height);

        Image scaledImage = image.getScaledInstance(width, height, BufferedImage.SCALE_SMOOTH);
        BufferedImage outImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
        Graphics2D g2 = (Graphics2D) outImage.createGraphics();
        g2.drawImage(scaledImage, 0, 0, null);

        return outImage;
    }

    public BufferedImage getImageFromArray(int[] pixels, int width, int height) {
        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        WritableRaster raster = (WritableRaster) image.getData();
        raster.setPixels(0,0,width,height,pixels);
        return image;
    }

}