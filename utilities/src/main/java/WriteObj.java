/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package jimagobject.utilities;

import java.io.File;
import java.io.FileWriter;
import java.util.HashSet;
import java.util.HashMap;
import java.util.TreeMap;
import java.util.Map;
import java.util.TreeSet;
import java.util.Vector;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

import jimagobject.utilities.LogFile;
import jimagobject.utilities.ReadImages;
import jimagobject.utilities.Picture;
import jimagobject.utilities.Marching.MarchingCubes;
import jimagobject.utilities.Marching.Vertex;
import jimagobject.utilities.Marching.VolumeGenerator;

import jimagobject.utilities.Meshcpp.MarchingCubesTransCpp;
import jimagobject.utilities.Meshcpp.Point;
import jimagobject.utilities.Meshcpp.Polygonise;
import jimagobject.utilities.Meshcpp.GridCell;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.*;
import java.nio.file.Path;
import java.nio.file.Paths;

public final class WriteObj {

    private final String fObj = "teste.obj";
    private Vector<byte[]> vbytesImages;
    private Vector<int[]> vRowsColumnsImages;
    private final ReadImages read = new ReadImages();
    private final MarchingCubes march = new MarchingCubes();

    private final MarchingCubesTransCpp meshcpp = new MarchingCubesTransCpp();
    private final LogFile log = new LogFile();

    public void getVertex() {

        // // String dirImages = "/home/icaro/Downloads/dicom/ABDOMEN/VOL_ARTERIAL_0004";
        // String dirImages = "/home/icaro/Downloads/dicom/teste/teste2";
        // // String dirImages = "/home/icaro/Downloads/dicom/teste/teste3";

        // File dir = new File(dirImages);
        // if(dir.exists()){
        //     read.read(dir);
        //     vbytesImages = read.getVbytesImages();
        //     // vRowsColumnsImages = read.getVRowsColumnsImages();

        //     write();
        //     // teste2();

        //     /**\/ painel de exibição da conversão da imagem; */
        //     // testeInstanciaDICOM();
        // }else{
        //     System.out.println("Diretório de imagens não existe;");
        // }

        testeCubo();
    }

    public void testeCubo() {

        float k = 72.0f;

        GridCell cubo = new GridCell(
            // new Point[]
            // {
            //     // f)
            //     new Point(1.0f, 29.0f, 0.0f), new Point(2.0f, 29.0f, 0.0f),// [7]-[6]
            //     new Point(1.0f, 28.0f, 0.0f), new Point(2.0f, 28.0f, 0.0f),// [3]-[2]
            //     // b)
            //     new Point(1.0f, 29.0f, 1.0f), new Point(2.0f, 29.0f, 1.0f),// [4]-[5]
            //     new Point(1.0f, 28.0f, 1.0f), new Point(2.0f, 28.0f, 1.0f) // [0]-[1]
            // },

            new Point[]
            {
                new Point(1.0f, 28.0f, 1.0f),
                new Point(2.0f, 28.0f, 1.0f),
                new Point(2.0f, 28.0f, 0.0f),
                new Point(1.0f, 28.0f, 0.0f),
                new Point(1.0f, 29.0f, 1.0f),
                new Point(2.0f, 29.0f, 1.0f),
                new Point(2.0f, 29.0f, 0.0f),
                new Point(1.0f, 29.0f, 0.0f)
            },
            new float[]
            {
                k,
                k,
                k+1,
                k+1,
                k,
                k,
                k+1,
                k
            }
        );

        Polygonise poly = new Polygonise();
        poly.applyTriangulate(cubo);
    }

    /** teste em exibir uma instância de imagem dicom convertendo para
     * imagem e aplicando o edge;
     */
    public void testeInstanciaDICOM(){
        int instance = 0;
        Vector<int[]> rowsColumns = read.getVRowsColumnsImages();
        boolean imagesPadroes = read.getImgPadrao();
        int rows = rowsColumns.get(instance)[0];
        int columns = rowsColumns.get(instance)[1];
        Picture pic = new Picture(vbytesImages.get(instance), columns, rows, imagesPadroes);
        pic.display();
    }

    /**\/ transcreve coordenadas de imagens para arquivo objeto; */
    public void write() {
        File logCheck = new File(fObj);
        FileWriter myWriter = null;
        boolean append = false;
        try {
            myWriter = new FileWriter(fObj, append);
        } catch (IOException e) { e.printStackTrace(); }

        applyDimensionsImg(myWriter);
        // teste2(myWriter);
        // teste3(myWriter);
        // readPoints();

        try {
            myWriter.close();
        } catch (IOException e) { e.printStackTrace(); }
    }

    /** extrair vertices de um cubo; */
    private GridCell getRect(int x, int y, int z, Picture picEdgeDetect, int salt){
        Color cor1 = picEdgeDetect.get(x, y);
        Color cor2 = picEdgeDetect.get(x, y+salt);
        Color cor3 = picEdgeDetect.get(x+salt, y);
        Color cor4 = picEdgeDetect.get(x+salt, y+salt);

        int argb1 = picEdgeDetect.getRGB(x, y);
        int argb2 = picEdgeDetect.getRGB(x, y+salt);
        int argb3 = picEdgeDetect.getRGB(x+salt, y);
        int argb4 = picEdgeDetect.getRGB(x+salt, y+salt);

        int alpha1 =  (argb1 >> 24) & 0xFF;
        int alpha2 =  (argb2 >> 24) & 0xFF;
        int alpha3 =  (argb3 >> 24) & 0xFF;
        int alpha4 =  (argb4 >> 24) & 0xFF;

        Point[] quad = new Point[4];
        GridCell cell = new GridCell();
        // if ( 
        //     (alpha1 == 255 && cor1.equals(Color.black)) &&
        //     (alpha2 == 255 && cor2.equals(Color.black)) &&
        //     (alpha3 == 255 && cor3.equals(Color.black)) &&
        //     (alpha4 == 255 && cor4.equals(Color.black))
        //  ){
            cell.vertex[0] = new Point(x, y, z);
            cell.vertex[1] = new Point(x, y+salt, z);
            cell.vertex[2] = new Point(x+salt, y, z);
            cell.vertex[3] = new Point(x+salt, y+salt, z);

            cell.value[0] = argb1;
            cell.value[1] = argb2;
            cell.value[2] = argb3;
            cell.value[3] = argb4;
        // }
        return cell;
    }

    public void applyDimensionsImg(FileWriter myWriter){
        int z = 0;
        double spaceBetweenLayers = 0.005;
        double xCoordScale = 0.01;
        double yCoordScale = 0.01;
        double sliceThickness = read.getSliceThickness();
        vRowsColumnsImages = read.getVRowsColumnsImages();
        boolean imagesPadroes = read.getImgPadrao();
        EdgeDetector edge = new EdgeDetector();

        // int i=10;{
        for(int i=0; i<vbytesImages.size(); i++){
            byte[] pixels = vbytesImages.get(i);
            /** \/ aplicação do edge detection; */
            int rows = vRowsColumnsImages.get(i)[0];
            int columns = vRowsColumnsImages.get(i)[1];
            Picture picEdgeDetect = edge.apply(pixels, columns, rows, imagesPadroes);
            for (int y = 1; y < picEdgeDetect.height() - 1; y++) {
                for (int x = 1; x < picEdgeDetect.width() - 1; x++) {

                    // cub
                    int salt = 1;
                    if(
                        (((y+salt) < picEdgeDetect.height()) && ((x+salt) < picEdgeDetect.width())) &&
                        ((i+salt) < vbytesImages.size())
                    ){
                        // frente
                        GridCell quad1 = getRect(x, y, z, picEdgeDetect, salt);

                        // fundo
                        byte[] pixels2 = vbytesImages.get(i+salt);
                        int rows2 = vRowsColumnsImages.get(i+salt)[0];
                        int columns2 = vRowsColumnsImages.get(i+salt)[1];
                        Picture picEdgeDetect2 = edge.apply(pixels2, columns2, rows2, imagesPadroes);

                        GridCell quad2 = getRect(x, y, z+salt, picEdgeDetect2, salt);

                        GridCell cubo = new GridCell();
                        // vertices;
                        cubo.vertex[0] = quad1.vertex[0];
                        cubo.vertex[1] = quad1.vertex[1];
                        cubo.vertex[2] = quad1.vertex[2];
                        cubo.vertex[3] = quad1.vertex[3];

                        cubo.vertex[4] = quad2.vertex[0];
                        cubo.vertex[5] = quad2.vertex[1];
                        cubo.vertex[6] = quad2.vertex[2];
                        cubo.vertex[7] = quad2.vertex[3];

                        // values;
                        cubo.value[0] = quad1.value[0];
                        cubo.value[1] = quad1.value[1];
                        cubo.value[2] = quad1.value[2];
                        cubo.value[3] = quad1.value[3];

                        cubo.value[4] = quad2.value[0];
                        cubo.value[5] = quad2.value[1];
                        cubo.value[6] = quad2.value[2];
                        cubo.value[7] = quad2.value[3];

                        Polygonise poly = new Polygonise();
                        poly.applyTriangulate(cubo);

                        // for(int k=0; k<8; k++){
                        //     System.out.println( k + " vert: [x:" + cubo.vertex[k].x + ", y:" + cubo.vertex[k].y + ", z:" + cubo.vertex[k].z+"]" );
                        // }
                        // System.out.println("***");
                        // break;
                    }
                    // cub

                    // Color cor = picEdgeDetect.get(x, y);
                    // int argb = picEdgeDetect.getRGB(x, y);
                    // int alpha =  (argb >> 24) & 0xFF;
                    // if (alpha == 255 && cor.equals(Color.black) ){
                    //     // x y z;
                    //     if(myWriter != null){
                    //         try {
                    //             log.createPointsInFile(x, y, z, cor.getRGB(), true);
                    //             myWriter.write("v " + (x) + " " + (y) + " " + z + "\n");
                    //         } catch (IOException e) { e.printStackTrace(); }
                    //     }
                    // }

                }
            }
            z += 1; // sliceThickness
        }
        System.out.println(">>FIM;");
    }

    /**\/ testar outra estratégia de mesh; */
    public void readPoints(){
        Polygonise poly = new Polygonise();
        float isovalue = 72.0f; // << default in project;
        // Vector<Vector<Vector<Float>>> scalar = meshcpp.createScalarFunction(xpicels);

        long maxPixelsLen = 0;
        for(int i=0; i<vbytesImages.size(); i++){
            byte[] pixels = vbytesImages.get(i);
            maxPixelsLen = Math.max(maxPixelsLen, pixels.length);
        }

        int nByPage = 100000;
        int minp = 1;
        int maxp = nByPage;
        while(maxp < maxPixelsLen){
            // System.out.println("Page: " + minp + " -> " + maxp);
            Vector<Point> pointsFile = log.readFilePoints(minp, maxp);
            Vector<Vector<Point>> triangles = meshcpp.triangulate_field(pointsFile, isovalue);
            // Vector<Vector<Point>> triangles = poly.triangulate_field(pointsFile, isovalue);
            System.out.println("Points:" + pointsFile.size() + " Triangles:" + triangles.size());

            // if(maxp > 500){ break; } // << testes;

            minp += maxp;
            maxp *= 2;
        }
        // log.readFileByPages(20);
        // log.deletarLog();
    }

    public void teste2(FileWriter myWriter){
        int z = 1;
        double spaceBetweenLayers = 0.005;
        double xCoordScale = 0.01;
        double yCoordScale = 0.01;
        double sliceThickness = read.getSliceThickness();
        vRowsColumnsImages = read.getVRowsColumnsImages();
        boolean imagesPadroes = read.getImgPadrao();
        EdgeDetector edge = new EdgeDetector();

        for(int i=0; i<vbytesImages.size(); i++){
            byte[] pixels = vbytesImages.get(i);
            /** \/ aplicação do edge detection; */
            int rows = vRowsColumnsImages.get(i)[0];
            int columns = vRowsColumnsImages.get(i)[1];
            Picture picEdgeDetect = edge.apply(pixels, columns, rows, imagesPadroes);

            int[][] allPoints = new int[picEdgeDetect.height()][picEdgeDetect.width()];

            for (int y = 0; y < picEdgeDetect.height(); y++) {
                for (int x = 0; x < picEdgeDetect.width(); x++) {
                    allPoints[y][x] = picEdgeDetect.getRGB(x, y);
                }
            }

            // march.calculatingFacets(allPoints,  myWriter);
        }

    }

    public void teste3(FileWriter myWriter){
        int z = 1;
        double spaceBetweenLayers = 0.005;
        double xCoordScale = 0.01;
        double yCoordScale = 0.01;
        double sliceThickness = read.getSliceThickness();
        vRowsColumnsImages = read.getVRowsColumnsImages();
        boolean imagesPadroes = read.getImgPadrao();
        EdgeDetector edge = new EdgeDetector();


        // byte[] pixels = vbytesImages.get(i);
        // /** \/ aplicação do edge detection; */
        // int rows = vRowsColumnsImages.get(i)[0];
        // int columns = vRowsColumnsImages.get(i)[1];
        // int[][] yxs = new int[picEdgeDetect.height()][picEdgeDetect.height()];
        // Picture picEdgeDetect = edge.apply(pixels, columns, rows, imagesPadroes);
        // for (int y = 1; y < picEdgeDetect.height() - 1; y++) {
        //     for (int x = 1; x < picEdgeDetect.width() - 1; x++) {
        //         // yxs[y][x] = 
        //         Vertex vert = new Vertex(x, y, z);
        //     }
        // }

        final int H = 1;
        Vector<Vertex> vVert = new Vector<Vertex>();


        // int i=0;
        for(int i=0; i<vbytesImages.size(); i++)
        {
            byte[] pixels = vbytesImages.get(i);
            /** \/ aplicação do edge detection; */
            int rows = vRowsColumnsImages.get(i)[0];
            int columns = vRowsColumnsImages.get(i)[1];
            Picture picEdgeDetect = edge.apply(pixels, columns, rows, imagesPadroes);

            // int[][] allPoints = new int[picEdgeDetect.height()][picEdgeDetect.width()];

            for (int y = 1; y < picEdgeDetect.height() - 1; y++) {
                for (int x = 1; x < picEdgeDetect.width() - 1; x++) {
                    // allPoints[y][x] = picEdgeDetect.getRGB(x, y);
                    Vertex vert = new Vertex(x, y, z);
                    // vVert.add( new Vertex(x - H, y - H, z) );
                    // vVert.add( new Vertex(x + H, y - H, z) );
                    // vVert.add( new Vertex(x - H, y + H, z) );
                    // vVert.add( new Vertex(x + H, y + H, z) );
                    if(!vVert.contains(vert)) vVert.add(vert);
                    // if(myWriter != null){
                    //     try {
                    //         myWriter.write("f " + (x) + " " + (y) + " " + (z) + "\n");
                    //         // myWriter.write("f " + (x + H) + " " + (y - H) + " " + (z) + "\n");
                    //         // myWriter.write("f " + (x - H) + " " + (y + H) + " " + (z) + "\n");
                    //         // myWriter.write("f " + (x + H) + " " + (y + H) + " " + (z) + "\n");
                    //     } catch (IOException e) { e.printStackTrace(); }
                    // }
                }
            }
            z++;
            march.calculatingFacets(vVert,  myWriter);
        }

        System.out.println(">>FIM;");
    }

    public int[] arrayBytesTArrayInt(byte[] gpixels){
        java.nio.IntBuffer intBuf =
        java.nio.ByteBuffer.wrap(gpixels)
            .order(java.nio.ByteOrder.LITTLE_ENDIAN)
            .asIntBuffer();
        int[] arrayPixels = new int[intBuf.remaining()];
        intBuf.get(arrayPixels);
        return arrayPixels;
    }

    public void teste4(byte[] gpixels, FileWriter myWriter){
        int z = 1;
        int[] arrayPixels = arrayBytesTArrayInt(gpixels);

        // arrayPixels = VolumeGenerator.generateScalarFieldInt(arrayPixels);
        // Vector<Integer> vecArrayPixels = VolumeGenerator.generateScalarVolume(arrayPixels);

        int[] size = {64, 64, 64};
        float[] voxSize = {1.0f, 1.0f, 1.0f};
        Vector<float[]> vmarch = march.marchingCubesInt(
            arrayPixels,
            new int[]{size[0], size[1], 2/*paddedSegmentSize*/},
            size[2],
            voxSize,
            5,/*0.5*/
            z
        );
        int id = 0;
        System.out.println("march: " + vmarch.size() + " -> " +  vmarch.get(id).length + " : " + vmarch.get(id)[0] + " : " + vmarch.get(id)[1] + " : " + vmarch.get(id)[2] );
        // for(float[] v: vmarch){
        //     if(myWriter != null){
        //         try {
        //             myWriter.write("f " + (v[0]) + " " + (v[1]) + " " + (v[2]) + "\n");
        //         } catch (IOException e) { e.printStackTrace(); }
        //     }
        // }
    }

}